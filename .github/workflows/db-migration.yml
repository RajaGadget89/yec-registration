name: Database Migration Pipeline (CI Only)

on:
  push:
    branches: [ develop, staging, bugfix/*, fix/*, feature/* ]
    paths:
      - 'migrations/**'
      - 'supabase/migrations/**'
      - '.github/workflows/db-migration.yml'
  pull_request:
    branches: [ main, develop, staging, bugfix/*, fix/*, feature/* ]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip migration tests (not recommended)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'
      force_migration:
        description: 'Force migration even if no changes detected'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

concurrency:
  group: db-migration-ci-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  statuses: write
  pull-requests: write

env:
  SUPABASE_CLI_VERSION: latest

jobs:
  # JOB 1: Quick Migration Validation (2-3 minutes) - ALWAYS RUNS FIRST
  quick_migration_validation:
    name: Quick Migration Validation
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      validation_passed: ${{ steps.validation_result.outputs.passed }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18.x
          cache: npm

      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: |
            node_modules
            ~/.cache/ms-playwright
            ~/.npm
          key: ${{ runner.os }}-deps-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-deps-

      - name: Install dependencies (cached)
        run: |
          npm ci --prefer-offline --no-audit
          npx playwright install --with-deps

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: ${{ env.SUPABASE_CLI_VERSION }}

      - name: Link to staging project for validation
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "Linking to staging project for quick validation..."
          supabase link --project-ref ${{ secrets.SB_STAGING_REF }} --password ${{ secrets.STAGING_DB_PASSWORD }}
          echo "âœ… Linked to staging project"

      - name: Run quick migration validation
        id: validation_result
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          SUPABASE_ENV: 'staging'
          CRON_SECRET: ${{ secrets.CRON_SECRET }}
          DISPATCH_DRY_RUN: 'true'
          NODE_ENV: 'test'
          NEXT_PUBLIC_APP_URL: 'http://localhost:3000'
          EMAIL_FROM: 'test@example.com'
          RESEND_API_KEY: 'test-key'
          TELEGRAM_BOT_TOKEN: 'test-token'
          TELEGRAM_CHAT_ID: 'test-chat-id'
        run: |
          set +e
          echo "Running quick migration validation tests..."
          
          # Run lightweight validation tests
          npx playwright test tests/e2e/migration-validation.e2e.spec.ts --reporter=line 2>&1 | tee quick-validation.log
          test_exit_code=$?
          
          if [ $test_exit_code -eq 0 ]; then
            echo "passed=true" >> $GITHUB_OUTPUT
            echo "âœ… Quick migration validation passed"
          else
            echo "passed=false" >> $GITHUB_OUTPUT
            echo "âŒ Quick migration validation failed with exit code: $test_exit_code"
            echo "ðŸ“‹ Validation log summary:"
            tail -20 quick-validation.log || echo "No validation log available"
          fi
          set -e

      - name: Upload validation log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: quick-validation-log
          path: quick-validation.log
          retention-days: 7

      - name: Cleanup staging connection
        if: always()
        run: |
          echo "Cleaning up staging connection..."
          supabase unlink || echo "No project linked to unlink"
          echo "âœ… Cleanup completed"

      # Always report status to satisfy ruleset requirements
      - name: Report required context (ruleset-compat)
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          JOB_STATUS: ${{ job.status }}
        with:
          script: |
            const stateMap = { success: 'success', failure: 'failure', cancelled: 'failure' };
            const state = stateMap[process.env.JOB_STATUS] || 'failure';
            const sha = context.payload.pull_request.head.sha;
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha,
              state,
              context: 'Database Migration Pipeline / Quick Migration Validation (pull_request)',
              description: `Reported from run ${context.runId}`,
              target_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            })

  # JOB 2: Detect Migration Changes - ONLY RUNS IF MIGRATIONS DETECTED OR FORCED
  detect_changes:
    name: Detect Migration Changes
    runs-on: ubuntu-latest
    needs: quick_migration_validation
    if: needs.quick_migration_validation.outputs.validation_passed == 'true'
    outputs:
      has_migrations: ${{ steps.filter.outputs.migrations }}
      migration_files: ${{ steps.filter.outputs.migration_files }}
      email_related_changes: ${{ steps.impact_analysis.outputs.email_related }}
      schema_only_changes: ${{ steps.impact_analysis.outputs.schema_only }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Detect migration changes
        id: filter
        uses: dorny/paths-filter@v3
        with:
          filters: |
            migrations:
              - 'migrations/**/*.sql'
              - 'supabase/migrations/**/*.sql'
              - '.github/workflows/db-migration.yml'

      - name: Analyze migration impact
        id: impact_analysis
        run: |
          echo "ðŸ” Analyzing migration impact..."
          
          # Initialize default values
          email_related=false
          schema_only=true
          
          # Only analyze if migrations are detected
          if [ "${{ steps.filter.outputs.migrations }}" == "true" ]; then
            # Check if migrations affect email-related tables
            email_tables=("email_outbox" "registrations" "audit_logs" "email_templates" "email_config")
            
            for file in migrations/*.sql; do
              if [ -f "$file" ]; then
                echo "Analyzing $file..."
                content=$(cat "$file" | tr '[:upper:]' '[:lower:]')
                
                # Check for email-related table changes
                for table in "${email_tables[@]}"; do
                  if echo "$content" | grep -q "$table"; then
                    echo "  - Found email-related table: $table"
                    email_related=true
                    schema_only=false
                  fi
                done
                
                # Check for email-related functions or triggers
                if echo "$content" | grep -E "(email|dispatch|notification|outbox)" | grep -E "(function|trigger|procedure)"; then
                  echo "  - Found email-related function/trigger"
                  email_related=true
                  schema_only=false
                fi
                
                # Check for data changes (INSERT, UPDATE, DELETE)
                if echo "$content" | grep -E "(insert|update|delete)" | grep -v "create\|alter\|drop"; then
                  echo "  - Found data changes"
                  schema_only=false
                fi
              fi
            done
          else
            echo "No migrations detected - using default values"
          fi
          
          echo "email_related=$email_related" >> $GITHUB_OUTPUT
          echo "schema_only=$schema_only" >> $GITHUB_OUTPUT
          
          echo "ðŸ“Š Impact Analysis Results:"
          echo "  Email-related changes: $email_related"
          echo "  Schema-only changes: $schema_only"

      - name: Debug migration detection and impact
        run: |
          echo "ðŸ” DEBUG: Migration detection and impact analysis:"
          echo "migrations: '${{ steps.filter.outputs.migrations }}'"
          echo "migration_files: '${{ steps.filter.outputs.migration_files }}'"
          echo "email_related: '${{ steps.impact_analysis.outputs.email_related }}'"
          echo "schema_only: '${{ steps.impact_analysis.outputs.schema_only }}'"
          
          # Early exit if no migrations detected (unless forced)
          if [ "${{ steps.filter.outputs.migrations }}" != "true" ] && [ "${{ github.event.inputs.force_migration }}" != "true" ]; then
            echo "âœ… No migration changes detected - skipping subsequent migration jobs"
            echo "This is expected behavior when no database schema changes are present"
          fi

      # Always report status to satisfy ruleset requirements
      - name: Report required context (ruleset-compat)
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          JOB_STATUS: ${{ job.status }}
        with:
          script: |
            const stateMap = { success: 'success', failure: 'failure', cancelled: 'failure' };
            const state = stateMap[process.env.JOB_STATUS] || 'failure';
            const sha = context.payload.pull_request.head.sha;
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha,
              state,
              context: 'Database Migration Pipeline / Detect Migration Changes (pull_request)',
              description: `Reported from run ${context.runId}`,
              target_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            })

  # JOB 3: Validate Migration Files - ONLY RUNS IF MIGRATIONS DETECTED
  validate_migrations:
    name: Validate Migration Files
    runs-on: ubuntu-latest
    needs: [quick_migration_validation, detect_changes]
    if: |
      needs.quick_migration_validation.outputs.validation_passed == 'true' &&
      needs.detect_changes.outputs.has_migrations == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: ${{ env.SUPABASE_CLI_VERSION }}

      - name: Validate migration syntax
        run: |
          echo "Validating migration files..."
          
          # Check for SQL syntax errors in migration files
          for file in migrations/*.sql; do
            if [ -f "$file" ]; then
              echo "Validating $file..."
              # Basic SQL syntax check
              if ! grep -q ";" "$file"; then
                echo "âŒ Error: $file appears to be missing semicolons"
                exit 1
              fi
              echo "âœ… $file syntax looks valid"
            fi
          done

      - name: Check migration naming convention
        run: |
          echo "Checking migration naming convention..."
          
          # Ensure migrations follow timestamp naming convention
          for file in migrations/*.sql; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              if ! [[ $filename =~ ^[0-9]{14}_.*\.sql$ ]]; then
                echo "âŒ Error: $filename doesn't follow timestamp naming convention (YYYYMMDDHHMMSS_description.sql)"
                exit 1
              fi
              echo "âœ… $filename follows naming convention"
            fi
          done

      # Always report status to satisfy ruleset requirements
      - name: Report required context (ruleset-compat)
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          JOB_STATUS: ${{ job.status }}
        with:
          script: |
            const stateMap = { success: 'success', failure: 'failure', cancelled: 'failure' };
            const state = stateMap[process.env.JOB_STATUS] || 'failure';
            const sha = context.payload.pull_request.head.sha;
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha,
              state,
              context: 'Database Migration Pipeline / Validate Migration Files (pull_request)',
              description: `Reported from run ${context.runId}`,
              target_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            })

  # JOB 4: Test Migrations (Shadow DB) - ONLY RUNS IF MIGRATIONS DETECTED
  test_migrations:
    name: Test Migrations (Shadow DB)
    runs-on: ubuntu-latest
    needs: [quick_migration_validation, detect_changes, validate_migrations]
    if: |
      needs.quick_migration_validation.outputs.validation_passed == 'true' &&
      needs.detect_changes.outputs.has_migrations == 'true' &&
      github.event.inputs.skip_tests != 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: ${{ env.SUPABASE_CLI_VERSION }}

      - name: Start local Supabase (shadow)
        run: |
          supabase start
          supabase status

      - name: Sync migrations to supabase/migrations
        run: |
          mkdir -p supabase/migrations
          rsync -a --delete migrations/ supabase/migrations/

      - name: Apply migrations to shadow database
        env:
          SHADOW_DB_URL: postgresql://postgres:postgres@localhost:54322/postgres
        run: |
          echo "Applying migrations to shadow database..."
          set -euo pipefail
          
          # Reset shadow database and apply all migrations
          printf 'y\n' | supabase db reset --db-url "$SHADOW_DB_URL"
          
          echo "âœ… Migrations applied successfully to shadow database"

      - name: Run database tests
        env:
          SHADOW_DB_URL: postgresql://postgres:postgres@localhost:54322/postgres
        run: |
          echo "Running database tests..."
          
          # Basic connectivity test
          psql "$SHADOW_DB_URL" -c "SELECT version();" || exit 1
          
          # Test that all expected tables exist
          psql "$SHADOW_DB_URL" -c "
            SELECT table_name 
            FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_type = 'BASE TABLE'
            ORDER BY table_name;
          " || exit 1
          
          echo "âœ… Database tests passed"

      - name: Stop local Supabase
        if: always()
        run: supabase stop

      # Always report status to satisfy ruleset requirements
      - name: Report required context (ruleset-compat)
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          JOB_STATUS: ${{ job.status }}
        with:
          script: |
            const stateMap = { success: 'success', failure: 'failure', cancelled: 'failure' };
            const state = stateMap[process.env.JOB_STATUS] || 'failure';
            const sha = context.payload.pull_request.head.sha;
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha,
              state,
              context: 'Database Migration Pipeline / Test Migrations (Shadow DB) (pull_request)',
              description: `Reported from run ${context.runId}`,
              target_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            })

  # JOB 5: Deploy to Staging - ONLY RUNS IF MIGRATIONS DETECTED
  deploy_staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [quick_migration_validation, detect_changes, validate_migrations, test_migrations]
    if: |
      needs.quick_migration_validation.outputs.validation_passed == 'true' &&
      needs.detect_changes.outputs.has_migrations == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: ${{ env.SUPABASE_CLI_VERSION }}

      - name: Link to staging project
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          supabase link --project-ref ${{ secrets.SB_STAGING_REF }} --password ${{ secrets.STAGING_DB_PASSWORD }}

      - name: Sync migrations to supabase/migrations
        run: |
          mkdir -p supabase/migrations
          rsync -a --delete migrations/ supabase/migrations/

      - name: Check remote migrations drift
        id: check_remote
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          set -euo pipefail
          supabase migration list --linked --password ${{ secrets.STAGING_DB_PASSWORD }} > migration_list.txt
          echo '--- Supabase migration list (linked) ---'
          cat migration_list.txt

          # Extract remote-only versions (Local column empty | Remote has a 14-digit version)
          MISSING=$(awk -F '|' '
            NR>2 {
              # trim all fields
              gsub(/^[ \t]+|[ \t]+$/, "", $1); # First field (might contain migration version)
              gsub(/^[ \t]+|[ \t]+$/, "", $2); # Local
              gsub(/^[ \t]+|[ \t]+$/, "", $3); # Remote
              # If Local is empty and first field contains a 14-digit version, it's missing
              if ($2 == "" && $1 ~ /^[0-9]{14}$/) print $1;
            }
          ' migration_list.txt | xargs)

          echo "missing_versions=$MISSING" >> "$GITHUB_OUTPUT"

          if [ -n "$MISSING" ]; then
            echo "::error::Remote-only migration versions not found locally: $MISSING\n" \
                 "Add stub files under supabase/migrations/<version>_remote_schema.sql (no-op) to align history, then re-run.";
            exit 1
          fi

      - name: Migrations in sync summary
        if: steps.check_remote.outputs.missing_versions == ''
        run: echo "Local and remote migration histories are aligned."

      - name: Generate migration diff
        id: diff
        run: |
          echo "Generating migration diff..."
          diff_output=$(supabase db diff --schema public --linked --password ${{ secrets.STAGING_DB_PASSWORD }} 2>&1 || echo "No diff or error")
          echo "diff_output<<EOF" >> $GITHUB_OUTPUT
          echo "$diff_output" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          if [ -n "$diff_output" ] && [ "$diff_output" != "No diff or error" ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Push migrations to staging
        if: steps.diff.outputs.has_changes == 'true' && steps.check_remote.outputs.missing_versions == ''
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "Pushing migrations to staging..."
          
          # Standard migration push (drift check already passed)
          supabase db push --password ${{ secrets.STAGING_DB_PASSWORD }}
          
          echo "âœ… Migrations deployed to staging"

      - name: No changes to deploy
        if: steps.diff.outputs.has_changes == 'false'
        run: |
          echo "No database changes detected. Skipping deployment."

      # Always report status to satisfy ruleset requirements
      - name: Report required context (ruleset-compat)
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          JOB_STATUS: ${{ job.status }}
        with:
          script: |
            const stateMap = { success: 'success', failure: 'failure', cancelled: 'failure' };
            const state = stateMap[process.env.JOB_STATUS] || 'failure';
            const sha = context.payload.pull_request.head.sha;
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha,
              state,
              context: 'Database Migration Pipeline / Deploy to Staging (pull_request)',
              description: `Reported from run ${context.runId}`,
              target_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            })

  # JOB 6: Full E2E Tests - ONLY RUNS FOR EMAIL-RELATED MIGRATIONS
  full_e2e_tests:
    name: Full E2E Tests
    runs-on: ubuntu-latest
    needs: [quick_migration_validation, detect_changes, validate_migrations, test_migrations, deploy_staging]
    if: |
      needs.quick_migration_validation.outputs.validation_passed == 'true' &&
      needs.detect_changes.outputs.has_migrations == 'true' &&
      needs.detect_changes.outputs.email_related_changes == 'true'
    timeout-minutes: 15
    outputs:
      tests_passed: ${{ steps.test_result.outputs.passed }}
    steps:
      - name: Debug full E2E condition
        run: |
          echo "ðŸ” DEBUG: Full E2E tests job condition check:"
          echo "quick_migration_validation.result: '${{ needs.quick_migration_validation.result }}'"
          echo "email_related_changes: '${{ needs.detect_changes.outputs.email_related_changes }}'"
          echo "Condition: needs.quick_migration_validation.outputs.validation_passed == 'true' && needs.detect_changes.outputs.email_related_changes == 'true'"

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18.x
          cache: npm

      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: |
            node_modules
            ~/.cache/ms-playwright
            ~/.npm
          key: ${{ runner.os }}-deps-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-deps-

      - name: Install OS dependencies for node-canvas
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential libcairo2-dev libpango1.0-dev libjpeg-dev \
            libgif-dev librsvg2-dev libpixman-1-dev

      - name: Install dependencies (cached)
        run: |
          npm ci --prefer-offline --no-audit
          npx playwright install --with-deps

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: ${{ env.SUPABASE_CLI_VERSION }}

      - name: Link to staging project for E2E tests
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "Linking to staging project for full E2E tests..."
          supabase link --project-ref ${{ secrets.SB_STAGING_REF }} --password ${{ secrets.STAGING_DB_PASSWORD }}
          echo "âœ… Linked to staging project"

      - name: Verify staging database connection
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "Verifying staging database connection..."
          supabase db diff --schema public --linked --password ${{ secrets.STAGING_DB_PASSWORD }} || echo "No pending changes (good!)"
          echo "âœ… Staging database connection verified"

      - name: Run full E2E tests
        id: test_result
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          SUPABASE_ENV: 'staging'
          CRON_SECRET: ${{ secrets.CRON_SECRET }}
          DISPATCH_DRY_RUN: 'true'
          NODE_ENV: 'test'
          NEXT_PUBLIC_APP_URL: 'http://localhost:3000'
          EMAIL_FROM: 'test@example.com'
          RESEND_API_KEY: 'test-key'
          TELEGRAM_BOT_TOKEN: 'test-token'
          TELEGRAM_CHAT_ID: 'test-chat-id'
        run: |
          set +e
          echo "Running full E2E tests against staging database..."
          
          # Run comprehensive E2E tests
          npx playwright test tests/e2e/dispatch-emails.e2e.spec.ts --reporter=line 2>&1 | tee full-e2e.log
          test_exit_code=$?
          
          if [ $test_exit_code -eq 0 ]; then
            echo "passed=true" >> $GITHUB_OUTPUT
            echo "âœ… Full E2E tests passed"
          else
            echo "passed=false" >> $GITHUB_OUTPUT
            echo "âŒ Full E2E tests failed with exit code: $test_exit_code"
            echo "ðŸ“‹ Test log summary:"
            tail -20 full-e2e.log || echo "No test log available"
          fi
          set -e

      - name: Upload full E2E log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: full-e2e-log
          path: full-e2e.log
          retention-days: 7

      - name: Attempt Auto-Fix
        if: |
          failure() && 
          needs.full_e2e_tests.outputs.tests_passed == 'false' &&
          github.event_name == 'pull_request'
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          SUPABASE_ENV: 'staging'
          CRON_SECRET: ${{ secrets.CRON_SECRET }}
          DISPATCH_DRY_RUN: 'true'
          NODE_ENV: 'test'
          NEXT_PUBLIC_APP_URL: 'http://localhost:3000'
          EMAIL_FROM: 'test@example.com'
          RESEND_API_KEY: 'test-key'
          TELEGRAM_BOT_TOKEN: 'test-token'
          TELEGRAM_CHAT_ID: 'test-chat-id'
        run: |
          npm run e2e:auto-fix:ci || true

      - name: Cleanup staging connection
        if: always()
        run: |
          echo "Cleaning up staging connection..."
          supabase unlink || echo "No project linked to unlink"
          echo "âœ… Cleanup completed"

      # Always report status to satisfy ruleset requirements
      - name: Report required context (ruleset-compat)
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          JOB_STATUS: ${{ job.status }}
        with:
          script: |
            const stateMap = { success: 'success', failure: 'failure', cancelled: 'failure' };
            const state = stateMap[process.env.JOB_STATUS] || 'failure';
            const sha = context.payload.pull_request.head.sha;
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha,
              state,
              context: 'Database Migration Pipeline / Full E2E Tests (pull_request)',
              description: `Reported from run ${context.runId}`,
              target_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            })

  # JOB 7: Deployment Summary - ALWAYS RUNS LAST
  deployment_summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [quick_migration_validation, detect_changes, validate_migrations, test_migrations, deploy_staging, full_e2e_tests]
    if: always()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Generate deployment summary
        uses: actions/github-script@v7
        with:
          script: |
            // Fetch jobs for the current workflow run
            const { data: { jobs } } = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId,
              per_page: 100,
            });

            let summary = `## Database Migration Pipeline Summary (CI Only)\n\n`;
            summary += `**Run ID:** ${context.runId}\n`;
            summary += `**Event:** ${context.eventName}\n`;
            summary += `**Branch:** ${context.ref}\n`;
            summary += `**Commit:** ${context.sha.substring(0, 7)}\n\n`;

            summary += `### Job Results\n\n`;

            // Map display labels to regex patterns that match actual job names
            const targets = [
              { label: 'quick_validation',          pattern: /Quick Migration Validation/i },
              { label: 'detect_changes',            pattern: /Detect Migration Changes/i },
              { label: 'validate_migrations',       pattern: /Validate Migration Files/i },
              { label: 'test_migrations',           pattern: /Test Migrations.*Shadow DB/i },
              { label: 'deploy_staging',            pattern: /Deploy to Staging/i },
              { label: 'full_e2e_tests',            pattern: /Full E2E Tests/i },
            ];

            for (const t of targets) {
              const job = jobs.find(j => t.pattern.test(j.name));
              if (!job) {
                summary += `â“ **${t.label}:** Not found\n`;
                continue;
              }
              const status = job.conclusion || job.status;
              const emoji =
                status === 'success' ? 'âœ…' :
                status === 'failure' ? 'âŒ' :
                status === 'cancelled' ? 'ðŸš«' : 'â³';
              summary += `${emoji} **${t.label}:** ${status}\n`;
            }

            summary += `\n### CI Pipeline Features\n`;
            summary += `- âš¡ **Quick Validation:** 2-3 minutes (always runs first)\n`;
            summary += `- ðŸ” **Smart Detection:** Only runs migration jobs when changes detected\n`;
            summary += `- ðŸ§ª **Comprehensive Testing:** Shadow DB + Staging deployment + E2E tests\n`;
            summary += `- ðŸš€ **Production Ready:** Use CD workflows for production deployment\n`;
            summary += `- ðŸ“Š **Clear Summary:** Always provides deployment summary\n\n`;
            
            // Check if any migration jobs were skipped
            const migrationJobs = ['validate_migrations', 'test_migrations', 'deploy_staging', 'full_e2e_tests'];
            const skippedJobs = migrationJobs.filter(jobName => {
              const job = jobs.find(j => j.name.toLowerCase().includes(jobName.replace('_', ' ')));
              return !job || job.conclusion === 'skipped';
            });
            
            if (skippedJobs.length > 0) {
              summary += `### Skipped Jobs\n`;
              summary += `The following jobs were skipped because no migration changes were detected:\n`;
              skippedJobs.forEach(job => {
                summary += `- ðŸš« **${job.replace('_', ' ')}**\n`;
              });
              summary += `\nThis is expected behavior when no database schema changes are present.\n\n`;
            }

            summary += `### Next Steps\n`;
            summary += `- [ ] Verify staging deployment\n`;
            summary += `- [ ] Review logs if any job failed\n`;
            summary += `- [ ] Use CD Standard Migration for production deployment\n`;
            summary += `- [ ] Monitor application functionality\n`;

            // If running on a PR, comment the summary
            if (context.eventName === 'pull_request') {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: summary,
              });
            }

            core.setOutput('summary', summary);

      # Always report status to satisfy ruleset requirements
      - name: Report required context (ruleset-compat)
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          JOB_STATUS: ${{ job.status }}
        with:
          script: |
            const stateMap = { success: 'success', failure: 'failure', cancelled: 'failure' };
            const state = stateMap[process.env.JOB_STATUS] || 'failure';
            const sha = context.payload.pull_request.head.sha;
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha,
              state,
              context: 'Database Migration Pipeline / Deployment Summary (pull_request)',
              description: `Reported from run ${context.runId}`,
              target_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            })