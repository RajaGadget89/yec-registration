name: Database Migration Pipeline

on:
  push:
    branches: [ develop, staging, bugfix/recover-core-services-system ]
    paths:
      - 'migrations/**'
      - 'supabase/migrations/**'
      - '.github/workflows/db-migration-optimized.yml'
  pull_request:
    branches: [ main, develop, staging, bugfix/recover-core-services-system ]
  workflow_dispatch:
    inputs:
      target_environment:
        description: 'Target environment for migration'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: 'Skip migration tests (not recommended)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'
      force_migration:
        description: 'Force migration even if no changes detected'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

concurrency:
  group: db-migration-${{ github.ref }}-${{ github.event.inputs.target_environment || 'staging' }}
  cancel-in-progress: false

permissions:
  contents: write
  statuses: write
  pull-requests: write

env:
  SUPABASE_CLI_VERSION: latest

jobs:
  # Detect changes in migration files with impact analysis
  detect_changes:
    name: Detect Migration Changes
    runs-on: ubuntu-latest
    outputs:
      has_migrations: ${{ steps.filter.outputs.migrations }}
      migration_files: ${{ steps.filter.outputs.migration_files }}
      email_related_changes: ${{ steps.impact.outputs.email_related }}
      schema_only_changes: ${{ steps.impact.outputs.schema_only }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Detect migration changes
        id: filter
        uses: dorny/paths-filter@v3
        with:
          filters: |
            migrations:
              - 'migrations/**/*.sql'
              - 'supabase/migrations/**/*.sql'
              - '.github/workflows/db-migration-optimized.yml'

      - name: Analyze migration impact
        id: impact
        if: steps.filter.outputs.migrations == 'true'
        run: |
          echo "ğŸ” Analyzing migration impact..."
          
          # Check if migrations affect email-related tables
          email_tables=("email_outbox" "registrations" "audit_logs" "email_templates" "email_config")
          email_related=false
          schema_only=true
          
          for file in migrations/*.sql; do
            if [ -f "$file" ]; then
              echo "Analyzing $file..."
              content=$(cat "$file" | tr '[:upper:]' '[:lower:]')
              
              # Check for email-related table changes
              for table in "${email_tables[@]}"; do
                if echo "$content" | grep -q "$table"; then
                  echo "  - Found email-related table: $table"
                  email_related=true
                  schema_only=false
                fi
              done
              
              # Check for email-related functions or triggers
              if echo "$content" | grep -E "(email|dispatch|notification|outbox)" | grep -E "(function|trigger|procedure)"; then
                echo "  - Found email-related function/trigger"
                email_related=true
                schema_only=false
              fi
              
              # Check for data changes (INSERT, UPDATE, DELETE)
              if echo "$content" | grep -E "(insert|update|delete)" | grep -v "create\|alter\|drop"; then
                echo "  - Found data changes"
                schema_only=false
              fi
            fi
          done
          
          echo "email_related=$email_related" >> $GITHUB_OUTPUT
          echo "schema_only=$schema_only" >> $GITHUB_OUTPUT
          
          echo "ğŸ“Š Impact Analysis Results:"
          echo "  Email-related changes: $email_related"
          echo "  Schema-only changes: $schema_only"

      - name: Set default impact values when no migrations
        if: steps.filter.outputs.migrations == 'false'
        run: |
          echo "email_related=false" >> $GITHUB_OUTPUT
          echo "schema_only=true" >> $GITHUB_OUTPUT

      - name: Debug migration detection and impact
        run: |
          echo "ğŸ” DEBUG: Migration detection and impact analysis:"
          echo "migrations: '${{ steps.filter.outputs.migrations }}'"
          echo "migration_files: '${{ steps.filter.outputs.migration_files }}'"
          echo "email_related: '${{ steps.impact.outputs.email_related }}'"
          echo "schema_only: '${{ steps.impact.outputs.schema_only }}'"

      - name: Set all contexts to success when no migrations
        if: steps.filter.outputs.migrations == 'false' && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const contexts = [
              'Database Migration Pipeline / Validate Migration Files (pull_request)',
              'Database Migration Pipeline / Test Migrations (Shadow DB) (pull_request)',
              'Database Migration Pipeline / Deploy to Staging (pull_request)',
              'Database Migration Pipeline / Deploy to Production (pull_request)',
              'Database Migration Pipeline / Quick Migration Validation (pull_request)',
              'Database Migration Pipeline / Full E2E Tests (pull_request)'
            ];
            
            for (const contextName of contexts) {
              await github.rest.repos.createCommitStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                sha: context.payload.pull_request.head.sha,
                state: 'success',
                context: contextName,
                description: 'No migration changes detected - skipping',
                target_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
              });
            }
            
            console.log('âœ… Set all migration contexts to success (no changes detected)');

      # Always report status to satisfy ruleset requirements
      - name: Report required context (ruleset-compat)
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          JOB_STATUS: ${{ job.status }}
        with:
          script: |
            const stateMap = { success: 'success', failure: 'failure', cancelled: 'failure' };
            const state = stateMap[process.env.JOB_STATUS] || 'failure';
            const sha = context.payload.pull_request.head.sha;
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha,
              state,
              context: 'Database Migration Pipeline / Detect Migration Changes (pull_request)',
              description: `Reported from run ${context.runId}`,
              target_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            })

  # Validate migration files
  validate_migrations:
    name: Validate Migration Files
    runs-on: ubuntu-latest
    needs: detect_changes
    if: needs.detect_changes.outputs.has_migrations == 'true' || github.event.inputs.force_migration == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: ${{ env.SUPABASE_CLI_VERSION }}

      - name: Validate migration syntax
        run: |
          echo "Validating migration files..."
          
          # Check for SQL syntax errors in migration files
          for file in migrations/*.sql; do
            if [ -f "$file" ]; then
              echo "Validating $file..."
              # Basic SQL syntax check
              if ! grep -q ";" "$file"; then
                echo "âŒ Error: $file appears to be missing semicolons"
                exit 1
              fi
              echo "âœ… $file syntax looks valid"
            fi
          done

      - name: Check migration naming convention
        run: |
          echo "Checking migration naming convention..."
          
          # Ensure migrations follow timestamp naming convention
          for file in migrations/*.sql; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              if ! [[ $filename =~ ^[0-9]{14}_.*\.sql$ ]]; then
                echo "âŒ Error: $filename doesn't follow timestamp naming convention (YYYYMMDDHHMMSS_description.sql)"
                exit 1
              fi
              echo "âœ… $filename follows naming convention"
            fi
          done

      # Always report status to satisfy ruleset requirements
      - name: Report required context (ruleset-compat)
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          JOB_STATUS: ${{ job.status }}
        with:
          script: |
            const stateMap = { success: 'success', failure: 'failure', cancelled: 'failure' };
            const state = stateMap[process.env.JOB_STATUS] || 'failure';
            const sha = context.payload.pull_request.head.sha;
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha,
              state,
              context: 'Database Migration Pipeline / Validate Migration Files (pull_request)',
              description: `Reported from run ${context.runId}`,
              target_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            })

  # Test migrations on shadow database
  test_migrations:
    name: Test Migrations (Shadow DB)
    runs-on: ubuntu-latest
    needs: detect_changes
    if: (needs.detect_changes.outputs.has_migrations == 'true' || github.event.inputs.force_migration == 'true') && github.event.inputs.skip_tests != 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: ${{ env.SUPABASE_CLI_VERSION }}

      - name: Start local Supabase (shadow)
        run: |
          supabase start
          supabase status

      - name: Sync migrations to supabase/migrations
        run: |
          mkdir -p supabase/migrations
          rsync -a --delete migrations/ supabase/migrations/

      - name: Apply migrations to shadow database
        env:
          SHADOW_DB_URL: postgresql://postgres:postgres@localhost:54322/postgres
        run: |
          echo "Applying migrations to shadow database..."
          set -euo pipefail
          
          # Reset shadow database and apply all migrations
          printf 'y\n' | supabase db reset --db-url "$SHADOW_DB_URL"
          
          echo "âœ… Migrations applied successfully to shadow database"

      - name: Run database tests
        env:
          SHADOW_DB_URL: postgresql://postgres:postgres@localhost:54322/postgres
        run: |
          echo "Running database tests..."
          
          # Basic connectivity test
          psql "$SHADOW_DB_URL" -c "SELECT version();" || exit 1
          
          # Test that all expected tables exist
          psql "$SHADOW_DB_URL" -c "
            SELECT table_name 
            FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_type = 'BASE TABLE'
            ORDER BY table_name;
          " || exit 1
          
          echo "âœ… Database tests passed"

      - name: Stop local Supabase
        if: always()
        run: supabase stop

      # Always report status to satisfy ruleset requirements
      - name: Report required context (ruleset-compat)
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          JOB_STATUS: ${{ job.status }}
        with:
          script: |
            const stateMap = { success: 'success', failure: 'failure', cancelled: 'failure' };
            const state = stateMap[process.env.JOB_STATUS] || 'failure';
            const sha = context.payload.pull_request.head.sha;
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha,
              state,
              context: 'Database Migration Pipeline / Test Migrations (Shadow DB) (pull_request)',
              description: `Reported from run ${context.runId}`,
              target_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            })

  # Deploy to staging environment
  deploy_staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: detect_changes
    if: |
      (needs.detect_changes.outputs.has_migrations == 'true' || github.event.inputs.force_migration == 'true') &&
      (github.event.inputs.target_environment == 'staging' || github.event.inputs.target_environment == null) &&
      (github.ref == 'refs/heads/staging' || github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch' || github.event_name == 'pull_request')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: ${{ env.SUPABASE_CLI_VERSION }}

      - name: Link to staging project
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          supabase link --project-ref ${{ secrets.SB_STAGING_REF }} --password ${{ secrets.STAGING_DB_PASSWORD }}

      - name: Sync migrations to supabase/migrations
        run: |
          mkdir -p supabase/migrations
          rsync -a --delete migrations/ supabase/migrations/

      - name: Generate migration diff
        id: diff
        run: |
          echo "Generating migration diff..."
          diff_output=$(supabase db diff --schema public --linked --password ${{ secrets.STAGING_DB_PASSWORD }} 2>&1 || echo "No diff or error")
          echo "diff_output<<EOF" >> $GITHUB_OUTPUT
          echo "$diff_output" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          if [ -n "$diff_output" ] && [ "$diff_output" != "No diff or error" ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Push migrations to staging
        if: steps.diff.outputs.has_changes == 'true'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "Pushing migrations to staging..."
          supabase db push --dry-run --password ${{ secrets.STAGING_DB_PASSWORD }}
          supabase db push --password ${{ secrets.STAGING_DB_PASSWORD }}
          echo "âœ… Migrations deployed to staging"

      - name: No changes to deploy
        if: steps.diff.outputs.has_changes == 'false'
        run: |
          echo "No database changes detected. Skipping deployment."

      # Always report status to satisfy ruleset requirements
      - name: Report required context (ruleset-compat)
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          JOB_STATUS: ${{ job.status }}
        with:
          script: |
            const stateMap = { success: 'success', failure: 'failure', cancelled: 'failure' };
            const state = stateMap[process.env.JOB_STATUS] || 'failure';
            const sha = context.payload.pull_request.head.sha;
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha,
              state,
              context: 'Database Migration Pipeline / Deploy to Staging (pull_request)',
              description: `Reported from run ${context.runId}`,
              target_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            })

  # Deploy to production (manual approval required)
  deploy_production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: detect_changes
    if: |
      (needs.detect_changes.outputs.has_migrations == 'true' || github.event.inputs.force_migration == 'true') &&
      github.event.inputs.target_environment == 'production' &&
      (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
    environment:
      name: production
      url: https://yec.rajagadget.live
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: ${{ env.SUPABASE_CLI_VERSION }}

      - name: Link to production project
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          supabase link --project-ref ${{ secrets.SB_PROD_REF }} --password ${{ secrets.PROD_DB_PASSWORD }}

      - name: Sync migrations to supabase/migrations
        run: |
          mkdir -p supabase/migrations
          rsync -a --delete migrations/ supabase/migrations/

      - name: Generate production migration diff
        id: prod_diff
        run: |
          echo "Generating production migration diff..."
          diff_output=$(supabase db diff --schema public --linked --password ${{ secrets.PROD_DB_PASSWORD }} 2>&1 || echo "No diff or error")
          echo "diff_output<<EOF" >> $GITHUB_OUTPUT
          echo "$diff_output" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          if [ -n "$diff_output" ] && [ "$diff_output" != "No diff or error" ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Push migrations to production
        if: steps.prod_diff.outputs.has_changes == 'true'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "Pushing migrations to production..."
          supabase db push --dry-run --password ${{ secrets.PROD_DB_PASSWORD }}
          supabase db push --password ${{ secrets.PROD_DB_PASSWORD }}
          echo "âœ… Migrations deployed to production"

      - name: No production changes to deploy
        if: steps.prod_diff.outputs.has_changes == 'false'
        run: |
          echo "No database changes detected for production. Skipping deployment."

      # Always report status to satisfy ruleset requirements
      - name: Report required context (ruleset-compat)
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          JOB_STATUS: ${{ job.status }}
        with:
          script: |
            const stateMap = { success: 'success', failure: 'failure', cancelled: 'failure' };
            const state = stateMap[process.env.JOB_STATUS] || 'failure';
            const sha = context.payload.pull_request.head.sha;
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha,
              state,
              context: 'Database Migration Pipeline / Deploy to Production (pull_request)',
              description: `Reported from run ${context.runId}`,
              target_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            })

  # JOB 1: Quick Migration Validation (2-3 minutes) - Always runs after deployment
  quick_migration_validation:
    name: Quick Migration Validation
    runs-on: ubuntu-latest
    needs: [detect_changes, deploy_staging, deploy_production]
    if: |
      always() && 
      (needs.deploy_staging.result == 'success' || needs.deploy_staging.result == 'skipped') &&
      (needs.deploy_production.result == 'success' || needs.deploy_production.result == 'skipped')
    timeout-minutes: 5
    concurrency:
      group: quick-validation-${{ github.ref }}
      cancel-in-progress: false
    outputs:
      validation_passed: ${{ steps.validation_result.outputs.passed }}
    steps:
      - name: Debug quick validation condition
        run: |
          echo "ğŸ” DEBUG: Quick migration validation job condition check:"
          echo "always(): true (always runs)"
          echo "deploy_staging.result: '${{ needs.deploy_staging.result }}'"
          echo "deploy_production.result: '${{ needs.deploy_production.result }}'"
          echo "email_related_changes: '${{ needs.detect_changes.outputs.email_related_changes }}'"
          echo "schema_only_changes: '${{ needs.detect_changes.outputs.schema_only_changes }}'"

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18.x
          cache: npm

      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: |
            node_modules
            ~/.cache/ms-playwright
            ~/.npm
          key: ${{ runner.os }}-deps-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-deps-

      - name: Install dependencies (cached)
        run: |
          npm ci --prefer-offline --no-audit
          npx playwright install --with-deps

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: ${{ env.SUPABASE_CLI_VERSION }}

      - name: Link to staging project for validation
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "Linking to staging project for quick validation..."
          supabase link --project-ref ${{ secrets.SB_STAGING_REF }} --password ${{ secrets.STAGING_DB_PASSWORD }}
          echo "âœ… Linked to staging project"

      - name: Run quick migration validation
        id: validation_result
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          SUPABASE_ENV: 'staging'
          CRON_SECRET: ${{ secrets.CRON_SECRET }}
          DISPATCH_DRY_RUN: 'true'
          NODE_ENV: 'test'
          NEXT_PUBLIC_APP_URL: 'http://localhost:3000'
          EMAIL_FROM: 'test@example.com'
          RESEND_API_KEY: 'test-key'
          TELEGRAM_BOT_TOKEN: 'test-token'
          TELEGRAM_CHAT_ID: 'test-chat-id'
        run: |
          set +e
          echo "Running quick migration validation tests..."
          
          # Run lightweight validation tests
          npx playwright test tests/e2e/migration-validation.e2e.spec.ts --reporter=line 2>&1 | tee quick-validation.log
          test_exit_code=$?
          
          if [ $test_exit_code -eq 0 ]; then
            echo "passed=true" >> $GITHUB_OUTPUT
            echo "âœ… Quick migration validation passed"
          else
            echo "passed=false" >> $GITHUB_OUTPUT
            echo "âŒ Quick migration validation failed with exit code: $test_exit_code"
            echo "ğŸ“‹ Validation log summary:"
            tail -20 quick-validation.log || echo "No validation log available"
          fi
          set -e

      - name: Upload validation log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: quick-validation-log
          path: quick-validation.log
          retention-days: 7

      - name: Cleanup staging connection
        if: always()
        run: |
          echo "Cleaning up staging connection..."
          supabase unlink || echo "No project linked to unlink"
          echo "âœ… Cleanup completed"

      # Always report status to satisfy ruleset requirements
      - name: Report required context (ruleset-compat)
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          JOB_STATUS: ${{ job.status }}
        with:
          script: |
            const stateMap = { success: 'success', failure: 'failure', cancelled: 'failure' };
            const state = stateMap[process.env.JOB_STATUS] || 'failure';
            const sha = context.payload.pull_request.head.sha;
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha,
              state,
              context: 'Database Migration Pipeline / Quick Migration Validation (pull_request)',
              description: `Reported from run ${context.runId}`,
              target_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            })

  # JOB 2: Full E2E Tests (8-10 minutes) - Only when email-related changes detected
  full_e2e_tests:
    name: Full E2E Tests
    runs-on: ubuntu-latest
    needs: [detect_changes, quick_migration_validation]
    if: |
      always() && 
      needs.quick_migration_validation.result == 'success' &&
      needs.detect_changes.outputs.email_related_changes == 'true'
    timeout-minutes: 15
    concurrency:
      group: full-e2e-tests-${{ github.ref }}
      cancel-in-progress: false
    outputs:
      tests_passed: ${{ steps.test_result.outputs.passed }}
    steps:
      - name: Debug full E2E condition
        run: |
          echo "ğŸ” DEBUG: Full E2E tests job condition check:"
          echo "always(): true (always runs)"
          echo "quick_migration_validation.result: '${{ needs.quick_migration_validation.result }}'"
          echo "email_related_changes: '${{ needs.detect_changes.outputs.email_related_changes }}'"
          echo "Condition: always() && needs.quick_migration_validation.result == 'success' && needs.detect_changes.outputs.email_related_changes == 'true'"
          echo "Condition evaluation:"
          echo "  always(): true"
          echo "  quick_validation check: ${{ needs.quick_migration_validation.result == 'success' }}"
          echo "  email_related check: ${{ needs.detect_changes.outputs.email_related_changes == 'true' }}"
          echo "  Final result: ${{ always() && needs.quick_migration_validation.result == 'success' && needs.detect_changes.outputs.email_related_changes == 'true' }}"

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18.x
          cache: npm

      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: |
            node_modules
            ~/.cache/ms-playwright
            ~/.npm
          key: ${{ runner.os }}-deps-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-deps-

      - name: Install OS dependencies for node-canvas
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential libcairo2-dev libpango1.0-dev libjpeg-dev \
            libgif-dev librsvg2-dev libpixman-1-dev

      - name: Install dependencies (cached)
        run: |
          npm ci --prefer-offline --no-audit
          npx playwright install --with-deps

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: ${{ env.SUPABASE_CLI_VERSION }}

      - name: Link to staging project for E2E tests
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "Linking to staging project for full E2E tests..."
          supabase link --project-ref ${{ secrets.SB_STAGING_REF }} --password ${{ secrets.STAGING_DB_PASSWORD }}
          echo "âœ… Linked to staging project"

      - name: Verify staging database connection
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "Verifying staging database connection..."
          supabase db diff --schema public --linked --password ${{ secrets.STAGING_DB_PASSWORD }} || echo "No pending changes (good!)"
          echo "âœ… Staging database connection verified"

      - name: Run full E2E tests
        id: test_result
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          SUPABASE_ENV: 'staging'
          CRON_SECRET: ${{ secrets.CRON_SECRET }}
          DISPATCH_DRY_RUN: 'true'
          NODE_ENV: 'test'
          NEXT_PUBLIC_APP_URL: 'http://localhost:3000'
          EMAIL_FROM: 'test@example.com'
          RESEND_API_KEY: 'test-key'
          TELEGRAM_BOT_TOKEN: 'test-token'
          TELEGRAM_CHAT_ID: 'test-chat-id'
        run: |
          set +e
          echo "Running full E2E tests against staging database..."
          
          # Run comprehensive E2E tests
          npx playwright test tests/e2e/dispatch-emails.e2e.spec.ts --reporter=line 2>&1 | tee full-e2e.log
          test_exit_code=$?
          
          if [ $test_exit_code -eq 0 ]; then
            echo "passed=true" >> $GITHUB_OUTPUT
            echo "âœ… Full E2E tests passed"
          else
            echo "passed=false" >> $GITHUB_OUTPUT
            echo "âŒ Full E2E tests failed with exit code: $test_exit_code"
            echo "ğŸ“‹ Test log summary:"
            tail -20 full-e2e.log || echo "No test log available"
          fi
          set -e

      - name: Upload full E2E log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: full-e2e-log
          path: full-e2e.log
          retention-days: 7

      - name: Attempt Auto-Fix
        if: |
          failure() && 
          needs.full_e2e_tests.outputs.tests_passed == 'false' &&
          github.event_name == 'pull_request'
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          SUPABASE_ENV: 'staging'
          CRON_SECRET: ${{ secrets.CRON_SECRET }}
          DISPATCH_DRY_RUN: 'true'
          NODE_ENV: 'test'
          NEXT_PUBLIC_APP_URL: 'http://localhost:3000'
          EMAIL_FROM: 'test@example.com'
          RESEND_API_KEY: 'test-key'
          TELEGRAM_BOT_TOKEN: 'test-token'
          TELEGRAM_CHAT_ID: 'test-chat-id'
        run: |
          npm run e2e:auto-fix:ci || true

      - name: Cleanup staging connection
        if: always()
        run: |
          echo "Cleaning up staging connection..."
          supabase unlink || echo "No project linked to unlink"
          echo "âœ… Cleanup completed"

      # Always report status to satisfy ruleset requirements
      - name: Report required context (ruleset-compat)
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          JOB_STATUS: ${{ job.status }}
        with:
          script: |
            const stateMap = { success: 'success', failure: 'failure', cancelled: 'failure' };
            const state = stateMap[process.env.JOB_STATUS] || 'failure';
            const sha = context.payload.pull_request.head.sha;
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha,
              state,
              context: 'Database Migration Pipeline / Full E2E Tests (pull_request)',
              description: `Reported from run ${context.runId}`,
              target_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            })

  # Create deployment summary
  deployment_summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [deploy_staging, deploy_production, quick_migration_validation, full_e2e_tests]
    if: always()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Generate deployment summary
        uses: actions/github-script@v7
        with:
          script: |
            // Fetch jobs for the current workflow run
            const { data: { jobs } } = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId,
              per_page: 100,
            });

            let summary = `## Database Migration Summary (Optimized)\n\n`;
            summary += `**Run ID:** ${context.runId}\n`;
            summary += `**Event:** ${context.eventName}\n`;
            summary += `**Branch:** ${context.ref}\n`;
            summary += `**Commit:** ${context.sha.substring(0, 7)}\n\n`;

            summary += `### Job Results\n\n`;

            // Map display labels to regex patterns that match actual job names
            const targets = [
              { label: 'detect_changes',            pattern: /Detect Migration Changes & Impact/i },
              { label: 'validate_migrations',       pattern: /Validate Migration Files/i },
              { label: 'test_migrations',           pattern: /Test Migrations.*Shadow DB/i },
              { label: 'deploy_staging',            pattern: /Deploy to Staging/i },
              { label: 'deploy_production',         pattern: /Deploy to Production/i },
              { label: 'quick_validation',          pattern: /Quick Migration Validation/i },
              { label: 'full_e2e_tests',            pattern: /Full E2E Tests/i },
            ];

            for (const t of targets) {
              const job = jobs.find(j => t.pattern.test(j.name));
              if (!job) {
                summary += `â“ **${t.label}:** Not found\n`;
                continue;
              }
              const status = job.conclusion || job.status;
              const emoji =
                status === 'success' ? 'âœ…' :
                status === 'failure' ? 'âŒ' :
                status === 'cancelled' ? 'ğŸš«' : 'â³';
              summary += `${emoji} **${t.label}:** ${status}\n`;
            }

            summary += `\n### Performance Improvements\n`;
            summary += `- âš¡ **Quick Validation:** 2-3 minutes (always runs)\n`;
            summary += `- ğŸš€ **Full E2E:** 8-10 minutes (only when email-related changes detected)\n`;
            summary += `- ğŸ“Š **Total Time Saved:** 5-8 minutes for schema-only changes\n\n`;

            summary += `### Next Steps\n`;
            summary += `- [ ] Verify staging\n`;
            summary += `- [ ] Review logs if any job failed\n`;
            summary += `- [ ] Promote to production when stable\n`;

            // If running on a PR, comment the summary
            if (context.eventName === 'pull_request') {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: summary,
              });
            }

            core.setOutput('summary', summary);