name: CD Standard Migration Pipeline

on:
  workflow_dispatch:
    inputs:
      target_environment:
        description: 'Target environment for CD migration'
        required: true
        default: 'production'
        type: choice
        options:
          - production
      skip_tests:
        description: 'Skip migration tests (not recommended)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'
      force_migration:
        description: 'Force migration even if no changes detected'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'
      force_sync:
        description: 'Force schema sync and resolve conflicts (for existing objects)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

concurrency:
  group: cd-standard-migration-${{ github.event.inputs.target_environment || 'production' }}
  cancel-in-progress: false

permissions:
  contents: write
  statuses: write
  pull-requests: write

env:
  SUPABASE_CLI_VERSION: latest

jobs:
  # Quick Migration Validation (pre-deployment check)
  quick_migration_validation:
    name: Quick Migration Validation
    runs-on: ubuntu-latest
    timeout-minutes: 5
    concurrency:
      group: quick-validation-${{ github.ref }}
      cancel-in-progress: false
    outputs:
      validation_passed: ${{ steps.validation_result.outputs.passed }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18.x
          cache: npm

      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: |
            node_modules
            ~/.cache/ms-playwright
            ~/.npm
          key: ${{ runner.os }}-deps-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-deps-

      - name: Install dependencies (cached)
        run: |
          npm ci --prefer-offline --no-audit
          npx playwright install --with-deps

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: ${{ env.SUPABASE_CLI_VERSION }}

      - name: Link to staging project for validation
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "Linking to staging project for quick validation..."
          supabase link --project-ref ${{ secrets.SB_STAGING_REF }} --password ${{ secrets.STAGING_DB_PASSWORD }}
          echo "‚úÖ Linked to staging project"

      - name: Run quick migration validation
        id: validation_result
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          SUPABASE_ENV: 'staging'
          CRON_SECRET: ${{ secrets.CRON_SECRET }}
          DISPATCH_DRY_RUN: 'true'
          NODE_ENV: 'test'
          NEXT_PUBLIC_APP_URL: 'http://localhost:3000'
          EMAIL_FROM: 'test@example.com'
          RESEND_API_KEY: 'test-key'
          TELEGRAM_BOT_TOKEN: 'test-token'
          TELEGRAM_CHAT_ID: 'test-chat-id'
        run: |
          set +e
          echo "Running quick migration validation tests..."
          
          # Run lightweight validation tests
          npx playwright test tests/e2e/migration-validation.e2e.spec.ts --reporter=line 2>&1 | tee quick-validation.log
          test_exit_code=$?
          
          if [ $test_exit_code -eq 0 ]; then
            echo "passed=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Quick migration validation passed"
          else
            echo "passed=false" >> $GITHUB_OUTPUT
            echo "‚ùå Quick migration validation failed with exit code: $test_exit_code"
            echo "üìã Validation log summary:"
            tail -20 quick-validation.log || echo "No validation log available"
          fi
          set -e

      - name: Upload validation log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: quick-validation-log
          path: quick-validation.log
          retention-days: 7

      - name: Cleanup staging connection
        if: always()
        run: |
          echo "Cleaning up staging connection..."
          supabase unlink || echo "No project linked to unlink"
          echo "‚úÖ Cleanup completed"

  # Detect changes in migration files (only if validation passes)
  detect_changes:
    name: Detect Migration Changes
    runs-on: ubuntu-latest
    needs: quick_migration_validation
    if: needs.quick_migration_validation.outputs.validation_passed == 'true'
    outputs:
      has_migrations: ${{ steps.filter.outputs.migrations }}
      migration_files: ${{ steps.filter.outputs.migration_files }}
      email_related_changes: ${{ steps.impact_analysis.outputs.email_related }}
      schema_only_changes: ${{ steps.impact_analysis.outputs.schema_only }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Detect migration changes
        id: filter
        uses: dorny/paths-filter@v3
        with:
          filters: |
            migrations:
              - 'migrations/**/*.sql'
              - 'supabase/migrations/**/*.sql'
              - '.github/workflows/cd-standard-migration.yml'

      - name: Analyze migration impact
        id: impact_analysis
        run: |
          echo "üîç Analyzing migration impact..."
          
          # Initialize default values
          email_related=false
          schema_only=true
          
          # Only analyze if migrations are detected
          if [ "${{ steps.filter.outputs.migrations }}" == "true" ]; then
            # Check if migrations affect email-related tables
            email_tables=("email_outbox" "registrations" "audit_logs" "email_templates" "email_config")
            
            for file in migrations/*.sql; do
              if [ -f "$file" ]; then
                echo "Analyzing $file..."
                content=$(cat "$file" | tr '[:upper:]' '[:lower:]')
                
                # Check for email-related table changes
                for table in "${email_tables[@]}"; do
                  if echo "$content" | grep -q "$table"; then
                    echo "  - Found email-related table: $table"
                    email_related=true
                    schema_only=false
                  fi
                done
                
                # Check for email-related functions or triggers
                if echo "$content" | grep -E "(email|dispatch|notification|outbox)" | grep -E "(function|trigger|procedure)"; then
                  echo "  - Found email-related function/trigger"
                  email_related=true
                  schema_only=false
                fi
                
                # Check for data changes (INSERT, UPDATE, DELETE)
                if echo "$content" | grep -E "(insert|update|delete)" | grep -v "create\|alter\|drop"; then
                  echo "  - Found data changes"
                  schema_only=false
                fi
              fi
            done
          else
            echo "No migrations detected - using default values"
          fi
          
          echo "email_related=$email_related" >> $GITHUB_OUTPUT
          echo "schema_only=$schema_only" >> $GITHUB_OUTPUT
          
          echo "üìä Impact Analysis Results:"
          echo "  Email-related changes: $email_related"
          echo "  Schema-only changes: $schema_only"

      - name: Debug migration detection and impact
        run: |
          echo "üîç DEBUG: Migration detection and impact analysis:"
          echo "migrations: '${{ steps.filter.outputs.migrations }}'"
          echo "migration_files: '${{ steps.filter.outputs.migration_files }}'"
          echo "email_related: '${{ steps.impact_analysis.outputs.email_related }}'"
          echo "schema_only: '${{ steps.impact_analysis.outputs.schema_only }}'"

  # Validate migration files (only if changes detected or forced)
  validate_migrations:
    name: Validate Migration Files
    runs-on: ubuntu-latest
    needs: detect_changes
    if: |
      (needs.detect_changes.outputs.has_migrations == 'true' || github.event.inputs.force_migration == 'true') &&
      needs.detect_changes.result == 'success'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: ${{ env.SUPABASE_CLI_VERSION }}

      - name: Validate migration syntax
        run: |
          echo "Validating migration files..."
          
          # Check for SQL syntax errors in migration files
          for file in migrations/*.sql; do
            if [ -f "$file" ]; then
              echo "Validating $file..."
              # Basic SQL syntax check
              if ! grep -q ";" "$file"; then
                echo "‚ùå Error: $file appears to be missing semicolons"
                exit 1
              fi
              echo "‚úÖ $file syntax looks valid"
            fi
          done

      - name: Check migration naming convention
        run: |
          echo "Checking migration naming convention..."
          
          # Ensure migrations follow timestamp naming convention
          for file in migrations/*.sql; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              if ! [[ $filename =~ ^[0-9]{14}_.*\.sql$ ]]; then
                echo "‚ùå Error: $filename doesn't follow timestamp naming convention (YYYYMMDDHHMMSS_description.sql)"
                exit 1
              fi
              echo "‚úÖ $filename follows naming convention"
            fi
          done

  # Test migrations on shadow database (only if validation passes)
  test_migrations:
    name: Test Migrations (Shadow DB)
    runs-on: ubuntu-latest
    needs: [detect_changes, validate_migrations]
    if: |
      (needs.detect_changes.outputs.has_migrations == 'true' || github.event.inputs.force_migration == 'true') &&
      needs.detect_changes.result == 'success' &&
      github.event.inputs.skip_tests != 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: ${{ env.SUPABASE_CLI_VERSION }}

      - name: Start local Supabase (shadow)
        run: |
          supabase start
          supabase status

      - name: Sync migrations to supabase/migrations
        run: |
          mkdir -p supabase/migrations
          rsync -a --delete migrations/ supabase/migrations/

      - name: Apply migrations to shadow database
        env:
          SHADOW_DB_URL: postgresql://postgres:postgres@localhost:54322/postgres
        run: |
          echo "Applying migrations to shadow database..."
          set -euo pipefail
          
          # Reset shadow database and apply all migrations
          printf 'y\n' | supabase db reset --db-url "$SHADOW_DB_URL"
          
          echo "‚úÖ Migrations applied successfully to shadow database"

      - name: Run database tests
        env:
          SHADOW_DB_URL: postgresql://postgres:postgres@localhost:54322/postgres
        run: |
          echo "Running database tests..."
          
          # Basic connectivity test
          psql "$SHADOW_DB_URL" -c "SELECT version();" || exit 1
          
          # Test that all expected tables exist
          psql "$SHADOW_DB_URL" -c "
            SELECT table_name 
            FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_type = 'BASE TABLE'
            ORDER BY table_name;
          " || exit 1
          
          echo "‚úÖ Database tests passed"

      - name: Stop local Supabase
        if: always()
        run: supabase stop



  # Deploy to production (only if all validations pass)
  deploy_production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [quick_migration_validation, detect_changes, validate_migrations, test_migrations]
    if: |
      (needs.detect_changes.outputs.has_migrations == 'true' || github.event.inputs.force_migration == 'true') &&
      needs.detect_changes.result == 'success' &&
      github.event.inputs.target_environment == 'production'
    environment:
      name: production
      url: https://yec.rajagadget.live
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: ${{ env.SUPABASE_CLI_VERSION }}

      - name: Link to production project
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          supabase link --project-ref ${{ secrets.SB_PROD_REF }} --password ${{ secrets.PROD_DB_PASSWORD }}

      - name: Sync migrations to supabase/migrations
        run: |
          mkdir -p supabase/migrations
          rsync -a --delete migrations/ supabase/migrations/

      - name: Pre-deployment conflict resolution (if force_sync enabled)
        if: github.event.inputs.force_sync == 'true'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "üîß Force sync enabled - resolving conflicts..."
          
          # Check for existing triggers that might conflict
          echo "Checking for existing triggers..."
          
          # Drop conflicting triggers if they exist
          echo "Dropping conflicting triggers if they exist..."
          psql "$(supabase db remote commit --password ${{ secrets.PROD_DB_PASSWORD }} | grep 'postgresql://' | head -1)" << 'EOF' 2>/dev/null || true
            DROP TRIGGER IF EXISTS trigger_log_deep_link_token_creation ON deep_link_tokens;
            DROP TRIGGER IF EXISTS trigger_log_deep_link_token_usage ON deep_link_tokens;
            DROP FUNCTION IF EXISTS log_deep_link_token_creation() CASCADE;
            DROP FUNCTION IF EXISTS log_deep_link_token_usage() CASCADE;
          EOF
          
          echo "‚úÖ Conflict resolution completed"

      - name: Generate production migration diff
        id: prod_diff
        run: |
          echo "Generating production migration diff..."
          diff_output=$(supabase db diff --schema public --linked --password ${{ secrets.PROD_DB_PASSWORD }} 2>&1 || echo "No diff or error")
          echo "diff_output<<EOF" >> $GITHUB_OUTPUT
          echo "$diff_output" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          if [ -n "$diff_output" ] && [ "$diff_output" != "No diff or error" ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Reconcile migrations (remote vs local)
        if: steps.prod_diff.outputs.has_changes == 'true'
        id: reconcile
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          set -euo pipefail
          npm i -g ts-node typescript >/dev/null 2>&1 || true
          ts-node .github/scripts/reconcile-migrations.ts

      - name: Show reconciliation result
        if: steps.prod_diff.outputs.has_changes == 'true'
        run: |
          echo "remote_only: ${{ steps.reconcile.outputs.remote_only }}"
          echo "local_only : ${{ steps.reconcile.outputs.local_only }}"

      # Stop if we just created stubs (PR needed)
      - name: Fail if new stubs were created (commit required)
        if: steps.prod_diff.outputs.has_changes == 'true' && steps.reconcile.outputs.remote_only != ''
        run: |
          echo "::error::Stub migrations created for remote-only versions. Commit them and re-run CD."
          exit 1

      - name: Push migrations to production
        if: steps.prod_diff.outputs.has_changes == 'true'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "Pushing migrations to production..."
          
          # First, try a dry run to see what would happen
          echo "Running dry run to check migration requirements..."
          dry_run_output=$(supabase db push --dry-run --password ${{ secrets.PROD_DB_PASSWORD }} 2>&1 || true)
          echo "Dry run output: $dry_run_output"
          
          # Continue to real push (the guard in SQL should make it safe)
          supabase db push --password ${{ secrets.PROD_DB_PASSWORD }} || {
            echo "::error::db push failed ‚Äî check for unguarded 'ADD CONSTRAINT ... USING INDEX' in migrations."
            exit 1
          }
          
          echo "‚úÖ Migrations deployed to production"

      - name: No production changes to deploy
        if: steps.prod_diff.outputs.has_changes == 'false'
        run: |
          echo "No database changes detected for production. Skipping deployment."

  # Create deployment summary (always runs)
  deployment_summary:
    name: CD Standard Migration Summary
    runs-on: ubuntu-latest
    needs: [quick_migration_validation, detect_changes, validate_migrations, test_migrations, deploy_production]
    if: always()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Generate deployment summary
        uses: actions/github-script@v7
        with:
          script: |
            // Fetch jobs for the current workflow run
            const { data: { jobs } } = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId,
              per_page: 100,
            });

            let summary = `## üöÄ CD Standard Migration Summary\n\n`;
            summary += `**Run ID:** ${context.runId}\n`;
            summary += `**Event:** ${context.eventName}\n`;
            summary += `**Target Environment:** ${context.payload.inputs?.target_environment || 'production'}\n`;
            summary += `**Force Sync:** ${context.payload.inputs?.force_sync || 'false'}\n`;
            summary += `**Branch:** ${context.ref}\n`;
            summary += `**Commit:** ${context.sha.substring(0, 7)}\n\n`;

            summary += `### Job Results\n\n`;

            // Map display labels to regex patterns that match actual job names
            const targets = [
              { label: 'quick_validation',          pattern: /Quick Migration Validation/i },
              { label: 'detect_changes',            pattern: /Detect Migration Changes/i },
              { label: 'validate_migrations',       pattern: /Validate Migration Files/i },
              { label: 'test_migrations',           pattern: /Test Migrations.*Shadow DB/i },
              { label: 'deploy_production',         pattern: /Deploy to Production/i },
            ];

            for (const t of targets) {
              const job = jobs.find(j => t.pattern.test(j.name));
              if (!job) {
                summary += `‚ùì **${t.label}:** Not found\n`;
                continue;
              }
              const status = job.conclusion || job.status;
              const emoji =
                status === 'success' ? '‚úÖ' :
                status === 'failure' ? '‚ùå' :
                status === 'cancelled' ? 'üö´' : '‚è≥';
              summary += `${emoji} **${t.label}:** ${status}\n`;
            }

            summary += `\n### CD Standard Migration Features\n`;
            summary += `- ‚ö° **Simple & Fast**: Direct supabase db push (proven CI approach)\n`;
            summary += `- üîí **Production Safe**: Manual approval required for production\n`;
            summary += `- üß™ **Comprehensive Testing**: Quick Validation + Shadow DB + Migration Testing\n`;
            summary += `- üîß **Conflict Resolution**: Force sync option for existing objects\n`;
            summary += `- üöÄ **Reliable**: Proper job ordering and dependency management\n\n`;

            summary += `### When to Use This Workflow\n`;
            summary += `- ‚úÖ **Standard schema changes** (new features, bug fixes)\n`;
            summary += `- ‚úÖ **Normal database migrations** (tables, indexes, policies)\n`;
            summary += `- ‚úÖ **Routine deployments** to production\n`;
            summary += `- ‚úÖ **Conflict scenarios** (use force_sync: true)\n`;
            summary += `- ‚ùå **NOT for**: Schema drift (use Schema Parity workflow)\n\n`;

            summary += `### Next Steps\n`;
            summary += `- [ ] Verify deployment in target environment\n`;
            summary += `- [ ] Review logs if any job failed\n`;
            summary += `- [ ] Monitor application functionality\n`;
            summary += `- [ ] Use Schema Parity workflow if drift detected\n`;

            // If running on a PR, comment the summary
            if (context.eventName === 'pull_request') {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: summary,
              });
            }

            core.setOutput('summary', summary);
